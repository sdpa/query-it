import { app } from 'electron'
import * as fs from 'fs/promises'
import * as path from 'path'
import { PostgresMetadata, PostgresColumnInfo, PostgresConstraintInfo } from '../backend/services/metadata/types'

const METADATA_FILENAME = 'db_schema_context.txt'

function getMetadataFilePath(): string {
  const userDataPath = app.getPath('userData')
  // Ensure the directory exists, especially if it's the first time or after an app update/reinstall
  // fs.mkdirSync(userDataPath, { recursive: true }); // Not strictly necessary for writeFile, but good practice for other uses.
                                                 // fs.writeFile will create non-existent directories if recursive option is available for it,
                                                 // but for simplicity, we'll rely on Electron ensuring userDataPath exists.
  return path.join(userDataPath, METADATA_FILENAME)
}

// This function is adapted from the previous ollamaService.ts
function formatDbMetadataForFile(metadata: PostgresMetadata): string {
  if (!metadata || (!metadata.tables?.length && !metadata.views?.length)) {
    return 'No database schema information available. Connect to a database and refresh schema via the app.'
  }

  let schemaString = 'Current Database Schema Context (as of last refresh):\n'
  schemaString += 'This file is automatically generated by QueryIt. Do not edit directly if you expect your changes to be used by the AI assistant.\n\n'


  const allTablesAndViews = [...(metadata.tables || []), ...(metadata.views || [])]

  allTablesAndViews.forEach((table) => {
    const isView = metadata.views?.some(v => v.name === table.name && v.schema === table.schema)
    schemaString += `\n${isView ? 'View' : 'Table'}: ${table.schema}.${table.name}\n`

    const tableColumns = metadata.columns?.filter((col: PostgresColumnInfo) => col.table === table.name) || []
    // Potential improvement: if PostgresColumnInfo included schema, filter would be:
    // metadata.columns?.filter((col: PostgresColumnInfo) => col.table === table.name && col.schema === table.schema)

    if (tableColumns.length > 0) {
      tableColumns.forEach((col) => {
        let columnDetails = `  - ${col.name}: ${col.dataType}`
        const pkConstraint = metadata.constraints?.find(
          (c: PostgresConstraintInfo) => c.table === table.name && c.column === col.name && c.type === 'PRIMARY KEY'
        )
        if (pkConstraint) columnDetails += ' (PK)'

        const fkConstraints = metadata.constraints?.filter(
          (c: PostgresConstraintInfo) => c.table === table.name && c.column === col.name && c.type === 'FOREIGN KEY'
        ) || []
        fkConstraints.forEach(fk => {
          columnDetails += ` (FK to ${fk.foreignTable}.${fk.foreignColumn})`
        })
        schemaString += `${columnDetails}\n`
      })
    } else {
      schemaString += `  (No column information available for this ${isView ? 'view' : 'table'})\n`
    }
  })

  // TODO: Consider adding other metadata like procedures, triggers if useful for the LLM context.
  // For now, focusing on tables, views, columns, and basic constraints.

  return schemaString
}

export async function updateMetadataFile(
  metadata: PostgresMetadata
): Promise<{ success: boolean; path?: string; error?: string }> {
  const filePath = getMetadataFilePath()
  try {
    if (!metadata || (!metadata.tables?.length && !metadata.views?.length)) {
      // If metadata is empty or not useful, we can choose to write an empty/informative file or delete existing.
      // Writing an informative message is better than deleting, as ollamaService can then read this.
      const emptyMessage = 'No database schema information available. Connect to a database and refresh the schema via the app.'
      await fs.writeFile(filePath, emptyMessage, 'utf-8')
      console.log(`Metadata file written with empty/no-schema message: ${filePath}`)
      return { success: true, path: filePath }
    }

    const formattedContent = formatDbMetadataForFile(metadata)
    await fs.writeFile(filePath, formattedContent, 'utf-8')
    console.log(`Metadata file updated successfully: ${filePath}`)
    return { success: true, path: filePath }
  } catch (error) {
    console.error(`Error writing metadata file to ${filePath}:`, error)
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred'
    return { success: false, error: `Failed to write metadata file: ${errorMessage}` }
  }
}

// Function to read the metadata file, will be used by ollamaService
export async function readMetadataFile(): Promise<string | null> {
  const filePath = getMetadataFilePath()
  try {
    if (fs.stat(filePath)) { // Check if file exists
        const content = await fs.readFile(filePath, 'utf-8')
        return content
    }
    return null; // File does not exist
  } catch (error) {
    // If error is because file doesn't exist, that's fine, return null.
    // Otherwise, it's an actual read error.
    if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
      console.log(`Metadata file not found at ${filePath}. Proceeding without schema context.`);
      return null;
    }
    console.error(`Error reading metadata file from ${filePath}:`, error)
    return null // Or throw, depending on how ollamaService should handle read errors
  }
}
